/**
 * @fileoverview Processor for extracting and converting Storyblok's ISbStoryData interface to Zod schema.
 * 
 * This module provides functionality to extract the ISbStoryData interface from the stor      });

      // Simple fix for StoryblokRichtext import
      fix      });      });

      // Simple fix for StoryblokRichtext import - replace the entire line
      fixedZodSchema = fixedZodSchema.replace(
        "import { type StoryblokRichtext } from 'PLACEHOLDER_IMPORT_PATH';",
        "import { type StoryblokRichtext } from '~/types/storyblok.d';"
      );

      // Register the schema in the native schema registry
      NativeSchemaRegistry.set("ISbStoryData", fixedZodSchema);
      
      Tracer.log(LogLevel.INFO, "Successfully extracted and converted ISbStoryData to Zod schema");imple fix for StoryblokRichtext import - replace the entire line
      fixedZodSchema = fixedZodSchema.replace(
        "import { type StoryblokRichtext } from 'PLACEHOLDER_IMPORT_PATH';",
        "import { type StoryblokRichtext } from '~/types/storyblok.d';"
      );

      // Register the schema in the native schema registry
      NativeSchemaRegistry.set("ISbStoryData", fixedZodSchema);a = fixedZodSchema.replace(
        /import\s*\{\s*type\s+StoryblokRichtext\s*\}\s*from\s*['"]PLACEHOLDER_IMPORT_PATH['"];?/g,
        "import { type StoryblokRichtext } from '~/types/storyblok.d';"
      );

      // Register the schema in the native schema registryok-js-client
 * package and convert it to a comprehensive Zod validation schema. It handles the complex generic types
 * present in the original interface by creating concrete versions and manages dependencies through 
 * minimal type stubs.
 * 
 * Key features:
 * - Extracts ISbStoryData from external npm packages using ts-morph
 * - Handles generic type parameters by creating concrete interface versions
 * - Generates comprehensive Zod schemas with all 39+ properties
 * - Integrates with the existing NativeSchemaRegistry system
 * - Supports self-referencing types through z.lazy() patterns
 * 
 * @author Generated by storyblok-to-zod
 * @version 1.0.0
 */

import { ExternalInterfaceExtractor } from "./externalInterfaceExtractor";
import extractSbInterfaceToZod from "./extractSbInterfaceToZod";
import { NativeSchemaRegistry } from "../statics/NativeSchemaRegistry";
import { LogLevel, Tracer } from "../statics/Tracer";
import { CLIOptions, ValidationError } from "../validation";
import { writeFileSync, mkdirSync } from "fs";
import { dirname, resolve } from "path";
import { Project } from "ts-morph";

/**
 * Creates a minimal source file with ISbStoryData and its dependencies, without generics.
 * This function removes generic type parameters from the ISbStoryData interface definition
 * and creates type stubs for its dependencies to ensure ts-to-zod compatibility.
 * 
 * @param originalInterface - The original ISbStoryData interface definition with generics
 * @returns A minimal source file containing the concrete interface and type stubs
 * @private
 */
function createMinimalISbStoryDataSource(originalInterface: string): string {
  // Create a concrete version of just the ISbStoryData interface without generics
  let concreteInterface = originalInterface;
  
  // Remove multi-line generic type parameters from interface declaration
  concreteInterface = concreteInterface.replace(
    /interface\s+ISbStoryData\s*<[\s\S]*?>\s*extends/g,
    'interface ISbStoryData extends'
  );
  
  // Replace any remaining Content type references with any
  concreteInterface = concreteInterface.replace(/:\s*Content[;,]/g, ': any;');
  concreteInterface = concreteInterface.replace(/:\s*Content$/gm, ': any');
  
  // Clean up any remaining generic references
  concreteInterface = concreteInterface.replace(/ISbComponentType<[^>]+>/g, 'any');

  // Create a minimal source file with better type definitions
  // Import the required types from their correct sources
  const minimalSource = `
// Import types from their correct sources
import { ISbMultipleStoriesData, ISbStoryData } from 'storyblok-js-client';
import { StoryblokRichtext } from '~/types/storyblok.d';

// Proper type definitions for ISbStoryData dependencies
interface ISbAlternateObject {
  id: number;
  name: string;
  slug: string;
  published: boolean;
  full_slug: string;
  is_folder: boolean;
  parent_id: number;
}

interface ISbLinkURLObject {
  id: number;
  name: string;
  slug: string;
  full_slug: string;
  url: string;
  uuid: string;
}

interface LocalizedPath {
  path: string;
  name: string | null;
  lang: string;
  published: boolean;
}

type PreviewToken = string;

// Re-declare the interfaces we need (they'll be imported from their proper sources)
// This is just for the ts-to-zod processing
${concreteInterface}
`;

  return minimalSource;
}

/**
 * Extracts the ISbStoryData interface from the storyblok-js-client package and converts it to a Zod schema.
 * This function handles the complex generic types in ISbStoryData by creating a concrete version
 * without generics, then uses ts-to-zod to generate a comprehensive validation schema.
 * 
 * The generated schema includes all 39+ properties from the original interface with proper type
 * mapping for strings, numbers, booleans, arrays, objects, unions, optionals, and self-references.
 * 
 * @param options - CLI options containing configuration for the extraction process
 * @throws {ValidationError} When ISbStoryData interface cannot be found or processed
 * @throws {Error} When extraction or conversion fails unexpectedly
 * 
 * @example
 * ```typescript
 * const options = { space: "my-space", debug: true };
 * extractAndConvertISbStoryData(options);
 * // Schema is automatically registered in NativeSchemaRegistry
 * ```
 */
export function extractAndConvertISbStoryData(options: CLIOptions): void {
  Tracer.log(LogLevel.DEBUG, "Starting ISbStoryData extraction and conversion", "extractAndConvertISbStoryData");

  const extractor = new ExternalInterfaceExtractor();

  try {
    // Extract the ISbStoryData interface from the correct package
    const interfaceDeclaration = extractor.extractInterfaceFromPackage("storyblok-js-client", "ISbStoryData");
    
    if (!interfaceDeclaration) {
      throw new ValidationError(
        "Could not find ISbStoryData interface in storyblok-js-client package. Make sure storyblok-js-client is installed.",
        { packageName: "storyblok-js-client", interfaceName: "ISbStoryData" }
      );
    }
    
    Tracer.log(LogLevel.DEBUG, `Successfully extracted ISbStoryData interface`);

    // Get the original interface text
    const originalInterfaceText = interfaceDeclaration.getText();
    
    // Check if the interface has generics (which ts-to-zod doesn't support)
    if (originalInterfaceText.includes('<') && originalInterfaceText.includes('>')) {
      Tracer.log(LogLevel.DEBUG, "Interface has generics, creating concrete version");
      
      // Create a temporary project with the concrete interface for conversion
      const tempProject = new Project({
        useInMemoryFileSystem: true,
        compilerOptions: {
          target: 99, // Latest
        },
      });
      
      // Instead of trying to process the full source file with all its complex types,
      // create a minimal source file with just ISbStoryData and type stubs
      const concreteSourceContent = createMinimalISbStoryDataSource(originalInterfaceText);
      
      const tempSourceFile = tempProject.createSourceFile("temp.ts", concreteSourceContent);
      const concreteInterface = tempSourceFile.getInterface("ISbStoryData");
      
      if (!concreteInterface) {
        throw new ValidationError("Failed to create concrete interface for ISbStoryData");
      }
      
      // Convert the concrete interface to Zod schema
      // We need to pass the full source content, not just the interface declaration
      const zodSchema = extractSbInterfaceToZod(concreteInterface, options, concreteSourceContent);
      
      if (!zodSchema || !zodSchema.trim()) {
        throw new ValidationError("Generated empty Zod schema for ISbStoryData interface");
      }

      // Fix self-referencing .shape properties that don't work with lazy schemas
      let fixedZodSchema = zodSchema.replace(/iSbStoryDataSchema\.shape\.lang/g, 'z.string()');
      
      // Fix ZodSchema type annotation issues with self-referencing lazy schemas
      fixedZodSchema = fixedZodSchema.replace(
        /: z\.ZodSchema<ISbStoryData[^>]*>/g,
        ': z.ZodType<any>'
      );
      
      // Fix .extend() calls on lazy schemas (iSbMultipleStoriesDataSchema.extend)
      // Replace the .extend() pattern with explicit object definition
      fixedZodSchema = fixedZodSchema.replace(
        /z\.lazy\(\(\) => iSbMultipleStoriesDataSchema\.extend\(/g,
        'z.lazy(() => z.object('
      );

      // Convert const declarations to export const for base schemas
      fixedZodSchema = fixedZodSchema.replace(
        /^const (iSbStoryDataSchema|iSbMultipleStoriesDataSchema):/gm,
        'export const $1:'
      );

      // Fix imports - replace placeholder with proper imports from correct sources
      fixedZodSchema = fixedZodSchema.replace(
        /import\s+\{\s*type\s+([^}]+)\s*\}\s+from\s+['"]PLACEHOLDER_IMPORT_PATH['"];?/g,
        (_match, types: string) => {
          const typeList = types.split(',').map((t: string) => t.trim()).filter(Boolean);
          const storyblokJsTypes = ['ISbStoryData', 'ISbMultipleStoriesData'];
          const localTypes = ['StoryblokRichtext'];
          
          const imports: string[] = [];
          
          // Separate types by their source
          const sbJsTypes = typeList.filter((t: string) => storyblokJsTypes.includes(t));
          const localStoryblokTypes = typeList.filter((t: string) => localTypes.includes(t));
          const unknownTypes = typeList.filter((t: string) => !storyblokJsTypes.includes(t) && !localTypes.includes(t));
          
          if (sbJsTypes.length > 0) {
            imports.push(`import { type ${sbJsTypes.join(', type ')} } from 'storyblok-js-client';`);
          }
          
          if (localStoryblokTypes.length > 0) {
            imports.push(`import { type ${localStoryblokTypes.join(', type ')} } from '~/types/storyblok.d';`);
          }
          
          // Keep unknown types with placeholder for now
          if (unknownTypes.length > 0) {
            imports.push(`import { type ${unknownTypes.join(', type ')} } from 'PLACEHOLDER_IMPORT_PATH';`);
          }
          
          return imports.join('\n');
        }
      );

      // Register the schema in the native schema registry
      NativeSchemaRegistry.set("ISbStoryData", fixedZodSchema);
      
      Tracer.log(LogLevel.INFO, "Successfully extracted and converted ISbStoryData to Zod schema");
      
    } else {
      // Interface doesn't have generics, process normally
      const zodSchema = extractSbInterfaceToZod(interfaceDeclaration, options);

      if (!zodSchema || !zodSchema.trim()) {
        throw new ValidationError("Generated empty Zod schema for ISbStoryData interface");
      }

      // Fix self-referencing .shape properties that don't work with lazy schemas
      let fixedZodSchema = zodSchema.replace(/iSbStoryDataSchema\.shape\.lang/g, 'z.string()');
      
      // Fix ZodSchema type annotation issues with self-referencing lazy schemas
      fixedZodSchema = fixedZodSchema.replace(
        /: z\.ZodSchema<ISbStoryData[^>]*>/g,
        ': z.ZodType<any>'
      );
      
      // Fix .extend() calls on lazy schemas (iSbMultipleStoriesDataSchema.extend)
      // Replace the .extend() pattern with explicit object definition
      fixedZodSchema = fixedZodSchema.replace(
        /z\.lazy\(\(\) => iSbMultipleStoriesDataSchema\.extend\(/g,
        'z.lazy(() => z.object('
      );

      // Convert const declarations to export const for base schemas
      fixedZodSchema = fixedZodSchema.replace(
        /^const (iSbStoryDataSchema|iSbMultipleStoriesDataSchema):/gm,
        'export const $1:'
      );

      // Fix imports - replace placeholder with proper imports from correct sources
      fixedZodSchema = fixedZodSchema.replace(
        /import\s+\{\s*type\s+([^}]+)\s*\}\s+from\s+['"]PLACEHOLDER_IMPORT_PATH['"];?/g,
        (_match, types: string) => {
          const typeList = types.split(',').map((t: string) => t.trim()).filter(Boolean);
          const storyblokJsTypes = ['ISbStoryData', 'ISbMultipleStoriesData'];
          const localTypes = ['StoryblokRichtext'];
          
          const imports: string[] = [];
          
          // Separate types by their source
          const sbJsTypes = typeList.filter((t: string) => storyblokJsTypes.includes(t));
          const localStoryblokTypes = typeList.filter((t: string) => localTypes.includes(t));
          const unknownTypes = typeList.filter((t: string) => !storyblokJsTypes.includes(t) && !localTypes.includes(t));
          
          if (sbJsTypes.length > 0) {
            imports.push(`import { type ${sbJsTypes.join(', type ')} } from 'storyblok-js-client';`);
          }
          
          if (localStoryblokTypes.length > 0) {
            imports.push(`import { type ${localStoryblokTypes.join(', type ')} } from '~/types/storyblok.d';`);
          }
          
          // Keep unknown types with placeholder for now
          if (unknownTypes.length > 0) {
            imports.push(`import { type ${unknownTypes.join(', type ')} } from 'PLACEHOLDER_IMPORT_PATH';`);
          }
          
          return imports.join('\n');
        }
      );

      // Simple fix for StoryblokRichtext import
      fixedZodSchema = fixedZodSchema.replace(
        /import\s*\{\s*type\s+StoryblokRichtext\s*\}\s*from\s*['"]PLACEHOLDER_IMPORT_PATH['"];?/g,
        "import { type StoryblokRichtext } from '~/types/storyblok.d';"
      );

      // Register the schema in the native schema registry
      NativeSchemaRegistry.set("ISbStoryData", fixedZodSchema);
      
      Tracer.log(LogLevel.INFO, "Successfully extracted and converted ISbStoryData to Zod schema");
    }

  } catch (error) {
    if (error instanceof ValidationError) {
      Tracer.log(LogLevel.ERROR, `Validation error processing ISbStoryData: ${error.message}`);
      throw error;
    }

    const wrappedError = new Error(
      `Failed to extract and convert ISbStoryData: ${error instanceof Error ? error.message : "Unknown error"}`
    );

    Tracer.log(LogLevel.ERROR, wrappedError.message);
    throw wrappedError;
  } finally {
    // Clean up resources
    extractor.dispose();
  }
}

/**
 * Ensures that the ISbStoryData schema is available in the NativeSchemaRegistry.
 * If the schema doesn't exist, it will be extracted and converted from the storyblok-js-client package.
 * If it already exists, this function returns immediately without re-processing.
 * 
 * This is the recommended way to access the ISbStoryData schema in your application,
 * as it provides lazy loading and caching behavior.
 * 
 * @param options - CLI options containing configuration for the extraction process
 * 
 * @example
 * ```typescript
 * // Ensure schema is available before using
 * ensureISbStoryDataSchema(options);
 * 
 * // Now you can safely get the schema from the registry
 * const schema = NativeSchemaRegistry.get("ISbStoryData");
 * ```
 */
export function ensureISbStoryDataSchema(options: CLIOptions): void {
  if (!NativeSchemaRegistry.has("ISbStoryData")) {
    Tracer.log(LogLevel.DEBUG, "ISbStoryData schema not found in registry, extracting...");
    extractAndConvertISbStoryData(options);
  } else {
    Tracer.log(LogLevel.DEBUG, "ISbStoryData schema already exists in registry");
  }
}

/**
 * Exports the ISbStoryData Zod schema to a file for use in other projects or as standalone validation.
 * This function ensures the schema is available, then writes it to the specified file path with
 * proper TypeScript formatting and necessary imports.
 * 
 * @param options - CLI options containing configuration for the extraction process
 * @param outputPath - The file path where the schema should be written (e.g., "./schemas/ISbStoryData.ts")
 * @param options.includeZodImport - Whether to include the Zod import statement (default: true)
 * @throws {ValidationError} When schema cannot be generated or file cannot be written
 * 
 * @example
 * ```typescript
 * // Export schema to a TypeScript file
 * exportISbStoryDataSchema(options, "./src/schemas/ISbStoryData.schema.ts");
 * 
 * // Export without Zod import (if importing from another file)
 * exportISbStoryDataSchema(options, "./schemas/ISbStoryData.ts", { includeZodImport: false });
 * ```
 */
export function exportISbStoryDataSchema(
  options: CLIOptions, 
  outputPath: string,
  exportOptions: { includeZodImport?: boolean } = {}
): void {
  const { includeZodImport = true } = exportOptions;
  
  try {
    // Ensure the schema is available in the registry
    ensureISbStoryDataSchema(options);
    
    // Get the schema from the registry
    const schema = NativeSchemaRegistry.get("ISbStoryData");
    
    if (!schema) {
      throw new ValidationError("ISbStoryData schema not found in registry after extraction attempt");
    }
    
    // Prepare the file content with proper imports and exports
    let fileContent = "";
    
    if (includeZodImport) {
      fileContent += `import { z } from "zod";\n\n`;
    }
    
    // Add a header comment
    fileContent += `/**
 * Auto-generated Zod schema for Storyblok's ISbStoryData interface
 * Generated by storyblok-to-zod
 * 
 * This schema validates Storyblok story data with all properties and types
 * including metadata, content, localization, and publishing information.
 */\n\n`;
    
    // Add the schema content
    fileContent += schema;
    
    // Ensure the output directory exists
    const outputDir = dirname(resolve(outputPath));
    mkdirSync(outputDir, { recursive: true });
    
    // Write the file
    writeFileSync(outputPath, fileContent, 'utf8');
    
    Tracer.log(LogLevel.INFO, `Successfully exported ISbStoryData schema to: ${outputPath}`);
    Tracer.log(LogLevel.DEBUG, `Schema file size: ${fileContent.length} characters`);
    
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    
    const wrappedError = new ValidationError(
      `Failed to export ISbStoryData schema to ${outputPath}: ${error instanceof Error ? error.message : "Unknown error"}`,
      { outputPath, includeZodImport }
    );
    
    Tracer.log(LogLevel.ERROR, wrappedError.message);
    throw wrappedError;
  }
}

/**
 * Exports the ISbStoryData schema to multiple common formats for different use cases.
 * This convenience function generates multiple output files in a structured way.
 * 
 * @param options - CLI options containing configuration for the extraction process  
 * @param baseOutputDir - Base directory for output files (default: "./schemas")
 * @throws {ValidationError} When schema cannot be generated or files cannot be written
 * 
 * @example
 * ```typescript
 * // Export to default schemas directory with multiple formats
 * exportISbStoryDataSchemaBundle(options);
 * 
 * // Export to custom directory
 * exportISbStoryDataSchemaBundle(options, "./src/types");
 * ```
 */
export function exportISbStoryDataSchemaBundle(
  options: CLIOptions,
  baseOutputDir: string = "./schemas"
): void {
  try {
    Tracer.log(LogLevel.INFO, `Exporting ISbStoryData schema bundle to: ${baseOutputDir}`);
    
    // Export standalone schema with Zod import
    const standaloneFile = resolve(baseOutputDir, "ISbStoryData.schema.ts");
    exportISbStoryDataSchema(options, standaloneFile, { includeZodImport: true });
    
    // Export schema without Zod import (for importing into larger files)
    const moduleFile = resolve(baseOutputDir, "ISbStoryData.schema.module.ts");
    exportISbStoryDataSchema(options, moduleFile, { includeZodImport: false });
    
    // Export a TypeScript type definition file
    ensureISbStoryDataSchema(options);
    const schema = NativeSchemaRegistry.get("ISbStoryData");
    if (schema) {
      const typeDefContent = `/**
 * TypeScript type definitions for ISbStoryData schema
 * Generated by storyblok-to-zod
 */

import { z } from "zod";
import { iSbStoryDataSchema } from "./ISbStoryData.schema";

export type ISbStoryDataType = z.infer<typeof iSbStoryDataSchema>;

// Export the schema for use in validation
export { iSbStoryDataSchema } from "./ISbStoryData.schema";
`;
      
      const typeDefFile = resolve(baseOutputDir, "ISbStoryData.types.ts");
      mkdirSync(dirname(typeDefFile), { recursive: true });
      writeFileSync(typeDefFile, typeDefContent, 'utf8');
      
      Tracer.log(LogLevel.INFO, `Exported TypeScript definitions to: ${typeDefFile}`);
    }
    
    Tracer.log(LogLevel.INFO, `Successfully exported ISbStoryData schema bundle to: ${baseOutputDir}`);
    
  } catch (error) {
    const wrappedError = new ValidationError(
      `Failed to export ISbStoryData schema bundle: ${error instanceof Error ? error.message : "Unknown error"}`,
      { baseOutputDir }
    );
    
    Tracer.log(LogLevel.ERROR, wrappedError.message);
    throw wrappedError;
  }
}