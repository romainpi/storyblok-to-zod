import chalk from "chalk";
import type { Components } from "@storyblok/management-api-client";
import fs from "fs/promises";
import path from "path";
import { Project } from "ts-morph";
import { generate } from "ts-to-zod";
import parseCliOptions from "./parseCliOptions";

// Global version variable injected by the build process
declare const __VERSION__: string;

console.log(chalk.bold("storyblok-to-zod"), `v${__VERSION__}`);

const options = parseCliOptions();

const cliConfig = {
  /** Show verbose information*/
  verbose: options.verbose || false,
  /** Storyblok space ID*/
  storyblokSpaceId: options.space || undefined,
};

const VERBOSE = cliConfig.verbose;
if (VERBOSE) {
  console.log("Verbose mode is", chalk.green("ON"));
  console.log();
}

const TYPES_PATH = "src/types/";

const JSON_PATH = `.storyblok/components/${cliConfig.storyblokSpaceId}/`;
if (!cliConfig.storyblokSpaceId) throw new Error("Missing Storyblok space ID");

// Extract the definition of interface StoryblokAsset from src/types/storyblok.d.ts
const STORYBLOK_TYPES_FILE_CONTENT = await fs.readFile(path.join(process.cwd(), TYPES_PATH, "storyblok.d.ts"), "utf-8");
const FILE_HEADER = `// Generated by storyblok-to-zod\nimport { z } from 'astro/zod';`;

/** A registry to store converted Zod schemas for Storyblok native types */
const schemaRegistry = new Map<string, string>();

// Load the storyblok.d.ts file using ts-morph to analyze imports
const storyblokTypesDefinitionFile = new Project().addSourceFileAtPath(
  path.join(process.cwd(), TYPES_PATH, "storyblok.d.ts")
);

for (const currentInterface of storyblokTypesDefinitionFile.getInterfaces()) {
  const type = currentInterface.getName();
  const schema = extractSbInterfaceToZod(type);
  schemaRegistry.set(type, schema);
}

debugTraceNewLine();

/** A dictionary to track which components have been converted */
const convertedComponents = new Map<string, string>();

// List all components in the JSON_PATH directory
const allFiles = await fs.readdir(path.join(process.cwd(), JSON_PATH));

const ignoredFiles = ["groups.json", "tags.json"];
const componentFiles = allFiles.filter((file) => file.endsWith(".json") && !ignoredFiles.includes(file));

// Scan all components and create a dependency graph to determine conversion order:
const componentDependencies = new Map<string, string[]>();
for (const fileName of componentFiles) {
  const componentName = path.basename(fileName, ".json");
  const fileContent = await fs.readFile(path.join(process.cwd(), JSON_PATH, fileName), "utf-8");
  const jsonSchema = JSON.parse(fileContent);
  const schemaData = jsonSchema.schema as Components.ComponentSchemaField[] | undefined;

  if (!jsonSchema || !schemaData) {
    console.warn(`Warning: Invalid or missing schema in JSON for component '${componentName}'. Skipping.`);
    continue;
  }

  const dependencies: string[] = [];
  for (const propName of Object.keys(schemaData)) {
    const value = schemaData[propName];
    if (value.type === "bloks" && Array.isArray(value.component_whitelist)) {
      dependencies.push(...value.component_whitelist);
    }
  }

  componentDependencies.set(componentName, dependencies);
}

// Simple topological sort to determine conversion order
const sortedComponents: string[] = [];
const visited = new Set<string>();

function visit(component: string, tempMarks: Set<string>) {
  if (tempMarks.has(component)) {
    throw new Error(`Cyclic dependency detected involving component '${component}'`);
  }
  if (!visited.has(component)) {
    tempMarks.add(component);
    const deps = componentDependencies.get(component) || [];
    for (const dep of deps) {
      if (componentDependencies.has(dep)) {
        visit(dep, tempMarks);
      }
    }
    tempMarks.delete(component);
    visited.add(component);
    sortedComponents.push(component);
  }
}

for (const component of componentDependencies.keys()) {
  visit(component, new Set<string>());
}

// Start conversion process
for (const componentName of sortedComponents) {
  await convertComponentJsonToZod(componentName);
}

const allNativeSchemas = Array.from(schemaRegistry.values()).join("\n");
const allComponentSchemas = Array.from(convertedComponents.values()).join("\n");

const finalContent = `\
${FILE_HEADER}
${allNativeSchemas}
${allComponentSchemas}`;

const outputFilePath = path.join(process.cwd(), TYPES_PATH, "storyblok.zod.ts");
await fs.writeFile(outputFilePath, finalContent, "utf-8");

/**
 * Converts a Storyblok component schema JSON file to a Zod schema definition.
 *
 * @param componentName - The name of the component (kebab-case) to convert, used to locate the JSON file
 * @returns A Promise that resolves to a string containing the generated Zod schema code
 *
 * @remarks
 * This function reads a JSON schema file from the configured JSON_PATH directory,
 * parses the Storyblok component schema, and generates corresponding Zod validation schema code.
 * The generated schema:
 * - Loads the JSON file for the specified component at `.storyblok/components/${STORYBLOK_SPACE_ID}/`
 * - Formats the component name with correct casing and 'Schema' suffix
 * - Maps Storyblok field types to appropriate Zod types using convertSbToZodType()
 * - Marks non-required fields as optional in the Zod schema
 *
 * @example
 * ```typescript
 * const schema = await convertToZod('hero-section');
 * // Returns: "export const heroSectionSchema = z.object({ ... });"
 * ```
 *
 * @throws Will throw an error if the JSON file cannot be read or parsed
 */
async function convertComponentJsonToZod(componentName: string): Promise<string> {
  debugTrace(`Enter with componentName='${componentName}'`, "convertComponentJsonToZod");

  // Load the JSON file for the component
  const inputFilePath = path.join(process.cwd(), JSON_PATH, componentName + ".json");
  const fileContent = await fs.readFile(inputFilePath, "utf-8");

  if (!fileContent) {
    throw new Error(`Could not read file for component '${componentName}' at path '${inputFilePath}'.`);
  }

  // Format the component name to camelCase and add 'Schema' suffix
  const componentNameCamel = kebabToCamelCase(componentName) + "Schema";
  let outputContent = `export const ${componentNameCamel} = z.object({\n`;

  // Parse the JSON content
  const jsonData = JSON.parse(fileContent);
  const schemaData = jsonData.schema as Components.ComponentSchemaField[] | undefined;

  if (!jsonData || !schemaData) {
    throw new Error(`Invalid or missing schema in JSON for component '${componentName}'.`);
  }

  for (const propName of Object.keys(schemaData)) {
    const value: Components.ComponentSchemaField = schemaData[propName];

    debugTrace(`propName: '${propName}', value.type: '${value.type}'`, "convertComponentJsonToZod");
    // console.log('Full property definition:', value);
    // console.log('---');

    if (!value.type) {
      console.warn(
        `Warning: Field '${propName}' in component '${componentName}' is missing a 'type' property. Defaulting to 'z.any()'. Full field definition:`,
        value
      );
      outputContent += `  ${propName}: z.any(),\n`;
      continue;
    }

    // Skip certain types
    const skippableTypes = ["tab", "section"];
    if (skippableTypes.includes(value.type)) {
      continue;
    }

    const required = value.required || false;

    const zodType = convertSbToZodType(value, componentName);

    outputContent += `  ${propName}: ${zodType}`;
    if (!required) {
      outputContent += `.optional()`;
    }
    outputContent += ",\n";
  }

  outputContent += "});\n";

  convertedComponents.set(componentName, outputContent);

  debugTraceNewLine();

  return outputContent;
}

/**
 * Converts a Storyblok field type to its corresponding Zod schema string representation.
 *
 * This function maps various Storyblok field types to appropriate Zod validation schemas,
 * handling primitive types, nested components, assets, and rich text content.
 *
 * @param value - The Storyblok field configuration object containing type and other metadata
 * @param parentComponentName - The name of the parent component that contains this field
 * @returns A string representation of the corresponding Zod schema
 *
 * @example
 * ```typescript
 * // For a text field
 * convertSbToZodType({ type: 'text' }, 'Hero') // Returns: 'z.string()'
 *
 * // For a bloks field with component whitelist
 * convertSbToZodType({
 *   type: 'bloks',
 *   component_whitelist: ['Button', 'Image']
 * }, 'Section') // Returns: 'z.any()'
 * ```
 *
 * @remarks
 * - String types (text, textarea) are converted to `z.string()`
 * - Bloks fields with component whitelists will log warnings for unconverted nested components
 * - Special Storyblok types like multilink, asset, and richtext use predefined schema references
 * - Options fields support both number and string values
 * - Fallback behavior returns `z.${storyblokType}()` for unhandled types
 */
function convertSbToZodType(value: Components.ComponentSchemaField, parentComponentName: string): string {
  debugTrace(
    `Enter with parentComponentName='${parentComponentName}', value.type='${value.type}'`,
    "convertSbToZodType",
    2
  );

  if (!value.type) {
    console.warn(
      `Warning: Field in component '${parentComponentName}' is missing a 'type' property. Defaulting to 'z.any()'. Full field definition:`,
      value
    );
    return "z.any()";
  }

  const storyblokType = value.type;

  const stringTypes = ["text", "textarea", "markdown"];
  const convertToAnyTypes: string[] = [];

  if (stringTypes.includes(storyblokType)) {
    return "z.string()";
  } else if (convertToAnyTypes.includes(storyblokType)) {
    return "z.any()";
  } else if (storyblokType === "bloks") {
    for (const componentName of value.component_whitelist || []) {
      if (!convertedComponents.has(componentName)) {
        console.warn(
          `Warning: Nested component '${componentName}' used in '${parentComponentName}' has not been converted yet.`
        );

        return "z.any()"; // Fallback to z.any() if nested component is not converted
      }
    }

    // Assign corresponding Zod schema for bloks field
    if (value.component_whitelist && value.component_whitelist.length > 0) {
      if (value.component_whitelist.length == 1) {
        // If only one component is whitelisted, use that schema directly
        const singleComponent = value.component_whitelist[0];
        return kebabToCamelCase(singleComponent) + "Schema";
      }
      const whitelistedComponents = value.component_whitelist
        .map((comp) => kebabToCamelCase(comp) + "Schema")
        .join(", ");
      return `z.union([${whitelistedComponents}])`;
    } else {
      return "z.any()"; // No whitelist means any component is allowed
    }
  } else if (storyblokType === "multilink") {
    return "storyblokMultilinkSchema";
  } else if (storyblokType === "option") {
    return "z.union([z.number(), z.string()])";
  } else if (storyblokType === "options") {
    return "z.array(z.union([z.number(), z.string()]))";
  } else if (storyblokType === "asset") {
    return "storyblokAssetSchema";
  } else if (storyblokType === "richtext") {
    return "storyblokRichtextSchema";
  }

  return `z.${storyblokType}()`;
}

/**
 * Extracts a TypeScript interface from Storyblok's types definitions and returns it to a Zod schema.
 *
 * @param typeName - The name of the type/interface to extract from the Storyblok types file
 * @returns A string containing the generated Zod schema with import statements and initial lines removed
 * @throws {Error} When the specified interface cannot be found in the storyblok.d.ts file
 *
 * @example
 * ```typescript
 * const zodSchema = extractInterfaceFromSbTypes('StoryblokAsset');
 * // Returns: "export const StoryblokAssetSchema = z.object({ ... });"
 * ```
 */
function extractSbInterfaceToZod(typeName: string): string {
  debugTrace(`Enter with typeName='${typeName}'`, "extractSbInterfaceToZod");

  const sbAssetInterfaceRegex = new RegExp(`interface ${typeName}( extends.*)* {[^}]+}`);
  const sbAssetMatch = STORYBLOK_TYPES_FILE_CONTENT.match(sbAssetInterfaceRegex);

  if (!sbAssetMatch) {
    throw new Error(`Could not find ${typeName} interface in storyblok.d.ts`);
  }

  const sbAssetInterface = sbAssetMatch[0];

  // Convert StoryblokAsset to Zod and use the result as the beginning of our file
  const schemaGenerator = generate({ sourceText: sbAssetInterface });
  const zodSchema = schemaGenerator.getZodSchemasFile("~/types/storyblok.d");

  // Remove the first two lines
  return zodSchema.split("\n").slice(2).join("\n").trim();
}

function kebabToCamelCase(text: string): string {
  return text.replace(/-\w/g, clearAndUpper);
}

function clearAndUpper(text: string): string {
  return text.replace(/-/, "").toUpperCase();
}

function debugTrace(message: string, componentName?: string, spacing: number = 0): void {
  if (VERBOSE) {
    const componentNamePart = componentName ? `${chalk.underline(componentName)}: ` : "";

    const spacingIndent = " ".repeat(spacing);
    const stringToShow = `${spacingIndent}${componentNamePart}${message}`;

    console.log(stringToShow);
  }
}

function debugTraceNewLine(): void {
  if (VERBOSE) {
    console.log();
  }
}
